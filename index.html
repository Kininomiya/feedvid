<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, minimum-scale=1, maximum-scale=1, user-scalable=no">
    <title>FeedVid</title>

    <style>
      html {
        padding: 0;
        margin: 0;
        height: 100%;
        user-select: none;
        -webkit-user-select: none;
        overflow: hidden;
        background-color: black;
      }
      body {
        padding: 0;
        margin: 0;
        background-color: black;
        height: 100%;
        overflow: hidden;
      }

      /* HARD HIDE the specific fullscreen icon and its clickable parent */
      svg.svg-inline--fa.fa-expand,
      svg[data-icon="expand"] {
        display: none !important;
        visibility: hidden !important;
        pointer-events: none !important;
      }

      /* Hide common clickable wrappers that contain the expand icon */
      button:has(svg.svg-inline--fa.fa-expand),
      a:has(svg.svg-inline--fa.fa-expand),
      [role="button"]:has(svg.svg-inline--fa.fa-expand),
      button:has(svg[data-icon="expand"]),
      a:has(svg[data-icon="expand"]),
      [role="button"]:has(svg[data-icon="expand"]) {
        display: none !important;
        visibility: hidden !important;
        pointer-events: none !important;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <svg>
      <filter id="glow-filter" >
        <feColorMatrix color-interpolation-filters="sRGB" in="SourceGraphic" type="matrix"
          values="1 0 0 0 -0.5
                  0 1 0 0 -0.5
                  0 0 1 0 -0.5
                  0 0 0 1 0"
          result="highlights" />
        <feColorMatrix color-interpolation-filters="sRGB" in="highlights" type="matrix"
          values="0.4 0 0 0 0
                  0 0.4 0 0 0
                  0 0 0.4 0 0
                  0 0 0 1 0"
          result="highlightsBright" />
        <feGaussianBlur color-interpolation-filters="sRGB" in="highlightsBright" stdDeviation="80" edgeMode="none" out="highlightsBlur"/>
        <feComposite color-interpolation-filters="sRGB" in2="SourceGraphic" in="highlightsBlur" operator="lighter"/>
      </filter>
    </svg>

    <style>
      .loader, .loader:after {
        border-radius: 50%;
        width: 10em;
        height: 10em;
      }
      .loader {
        position: absolute;
        left: 50%;
        top: 50%;
        z-index: 10;
        font-size: 10px;
        text-indent: -9999em;
        border-top: 1.1em solid rgba(255, 255, 255, 0.2);
        border-right: 1.1em solid rgba(255, 255, 255, 0.2);
        border-bottom: 1.1em solid rgba(255, 255, 255, 0.2);
        border-left: 1.1em solid #ffffff;
        transform: translate3d(-50%, -50%, 0);
        animation: load8 1.1s infinite linear;
      }
      @keyframes load8 {
        0% { transform: translate3d(-50%, -50%, 0) rotate(0deg); }
        100% { transform: translate3d(-50%, -50%, 0) rotate(360deg); }
      }
    </style>

    <div id="loading-spinner" class="loader">Loading...</div>

    <!-- Robust runtime removal (covers late-injected controls) -->
    <script>
      (function killExpandFullscreenEverywhere() {
        function hideOrRemove(el) {
          try { el.remove(); }
          catch {
            el.style.display = 'none';
            el.style.visibility = 'hidden';
            el.style.pointerEvents = 'none';
            el.setAttribute('hidden', '');
            el.innerHTML = '';
          }
        }

        function sweep(root = document) {
          // Remove the exact icon(s)
          root.querySelectorAll('svg.svg-inline--fa.fa-expand, svg[data-icon="expand"]').forEach(svg => {
            const parent = svg.closest('button, a, [role="button"], div');
            hideOrRemove(parent || svg);
          });

          // Extra: sometimes the icon is wrapped in multiple layers; walk up a bit
          root.querySelectorAll('svg.svg-inline--fa.fa-expand, svg[data-icon="expand"]').forEach(svg => {
            let p = svg.parentElement, hops = 0;
            while (p && hops < 3) {
              if (getComputedStyle(p).cursor === 'pointer' || ['BUTTON','A'].includes(p.tagName) || p.getAttribute('role') === 'button') {
                hideOrRemove(p);
                break;
              }
              p = p.parentElement; hops++;
            }
          });
        }

        // Initial + staged sweeps
        sweep();
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => { sweep(); setTimeout(sweep, 0); setTimeout(sweep, 100); });
        } else {
          setTimeout(sweep, 0);
          setTimeout(sweep, 100);
        }

        // Mutation observer for anything injected later by the app
        const mo = new MutationObserver(muts => {
          for (const m of muts) {
            m.addedNodes && m.addedNodes.forEach(n => n.nodeType === 1 && sweep(n));
          }
        });
        mo.observe(document.documentElement, { childList: true, subtree: true });

        // Belt-and-suspenders: periodic sweeps for 30s
        const interval = setInterval(sweep, 1000);
        setTimeout(() => clearInterval(interval), 30000);
      })();
    </script>

    <script type="text/javascript" src="bundle.js"></script>
  </body>
</html>
```
